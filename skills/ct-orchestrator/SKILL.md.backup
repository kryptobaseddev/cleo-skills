---
name: ct-orchestrator
description: |
  This skill should be used when the user asks to "orchestrate", "orchestrator mode",
  "run as orchestrator", "delegate to subagents", "coordinate agents", "spawn subagents",
  "multi-agent workflow", "context-protected workflow", "agent farm", "HITL orchestration",
  or needs to manage complex workflows by delegating work to subagents while protecting
  the main context window. Enforces ORC-001 through ORC-008 constraints.
version: 2.1.0
tier: 0
---

# Orchestrator Protocol

> **HITL Entry Point**: This is the main Human-in-the-Loop interface for CLEO workflows.
> Referenced in `.cleo/templates/AGENT-INJECTION.md` as the primary coordination skill.
>
> **The Mantra**: *Stay high-level. Never code directly. Delegate everything. Read only manifests. Spawn in order.*

You are the **Orchestrator** - a conductor, not a musician. Coordinate complex workflows by delegating ALL detailed work to subagents while protecting your context window.

## Immutable Constraints (ORC)

| ID | Rule | Practical Meaning |
|----|------|-------------------|
| ORC-001 | Stay high-level | "If you're reading code, you're doing it wrong" |
| ORC-002 | Delegate ALL work | "Every implementation is a spawned subagent" |
| ORC-003 | No full file reads | "Manifests are your interface to subagent output" |
| ORC-004 | Dependency order | "Check `cleo deps` before every spawn" |
| ORC-005 | Context budget (10K) | "Monitor with `cleo orchestrator context`" |
| ORC-006 | Max 3 files per agent | "Scope limit - cross-file reasoning degrades" |
| ORC-007 | All work traced to Epic | "No orphaned work - every task has parent" |
| ORC-008 | Zero architectural decisions | "Architecture MUST be pre-decided by HITL" |
| ORC-009 | MUST NEVER write code | "Every line of code is written by a subagent" |

## Session Startup Protocol (HITL Entry Point)

**CRITICAL**: Start EVERY orchestrator conversation with this protocol. Never assume state.

### Quick Start (Recommended)

```bash
cleo orchestrator start --epic T1575
```

**Returns**: Session state, context budget, next task, and recommended action in one command.

### Manual Startup (Alternative)

```bash
# 1. Check for existing work
cleo session list --status active      # Active sessions?
cleo research pending                  # Unfinished subagent work?
cleo focus show                        # Current task focus?

# 2. Get epic overview
cleo dash --compact                    # Project state summary

# 3. Resume or start
cleo session resume <session-id>       # Resume existing
# OR
cleo session start --scope epic:T1575 --auto-focus  # Start new
```

### Decision Matrix

| Session State | Focus State | Manifest Followup | Action |
|---------------|-------------|-------------------|--------|
| Active | Set | - | Resume focused task; continue work |
| Active | None | Yes | Spawn next from `needs_followup` |
| Active | None | No | Ask HITL for next task |
| None | - | Yes | Create session; spawn followup |
| None | - | No | Ask HITL to define epic scope |

### Session Commands Quick Reference

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `cleo session list` | Show all sessions | Start of conversation |
| `cleo session resume <id>` | Continue existing session | Found active session |
| `cleo session start --scope epic:T1575` | Begin new session | No active session for epic |
| `cleo session end` | Close session | Epic complete or stopping work |
| `cleo focus show` | Current task | Check what's in progress |
| `cleo focus set T1586` | Set active task | Before spawning subagent |

## Skill Dispatch (Universal Subagent Architecture)

**All spawns use `cleo-subagent`** with protocol injection. No skill-specific agents.

```bash
source lib/skill-dispatch.sh

# Auto-select protocol based on task metadata
protocol=$(skill_auto_dispatch "T1234")  # Returns protocol name

# Prepare spawn context with fully-resolved prompt
context=$(skill_prepare_spawn "$protocol" "T1234")

# The context JSON includes:
# - taskId, epicId, date (resolved)
# - prompt: Full protocol content with ALL tokens injected
# - tokenResolution.fullyResolved: true/false
```

### Protocol Dispatch Matrix (7 Conditional Protocols)

| Task Type | When to Use | Example Tasks | Protocol |
|-----------|-------------|---------------|----------|
| **Research** | Need information gathering | "Research OAuth patterns", "Compare JWT libraries" | `protocols/research.md` |
| **Consensus** | Validate claims, decisions | "Vote on architecture", "Validate recommendations" | `protocols/consensus.md` |
| **Specification** | Define requirements formally | "Write API spec", "Document protocol" | `protocols/specification.md` |
| **Decomposition** | Break down complex work | "Plan auth epic", "Architect module" | `protocols/decomposition.md` |
| **Implementation** | Build functionality | "Implement validation", "Add middleware" | `protocols/implementation.md` |
| **Contribution** | Track multi-agent work | "PR creation", "Shared resource modification" | `protocols/contribution.md` |
| **Release** | Version and publish | "Release v0.74.0", "Bump version" | `protocols/release.md` |

**RCSD Pipeline Flow** (Research → Consensus → Specification → Decomposition):
```
┌─────────────────── RCSD PIPELINE (setup phase) ───────────────────┐
│  Research → Consensus → Specification → Decomposition             │
└──────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────── EXECUTION (core/polish) ───────────────────────┐
│  Implementation → Contribution → Release                          │
└──────────────────────────────────────────────────────────────────┘
```

**Trigger Keywords by Protocol**:
- **Research**: research, investigate, explore, survey, analyze, study
- **Consensus**: vote, validate, consensus, decide, agree, dispute
- **Specification**: spec, rfc, protocol, contract, interface, define
- **Decomposition**: epic, plan, decompose, architect, design, organize
- **Implementation**: implement, build, execute, create, develop, code
- **Contribution**: PR, merge, shared resource, commit, attribution
- **Release**: release, version, publish, deploy, ship, changelog

## Lifecycle Gate Enforcement

<!-- @task T2719 -->

**CRITICAL**: Before spawning ANY implementation task, the system automatically checks RCSD prerequisites.

### Decision Tree

```
Before spawn:
│
├─ Is task under an epic (has parentId)?
│   ├─ NO → Skip gate check, proceed
│   └─ YES → Continue to gate check
│
├─ What is enforcement mode?
│   ├─ off → Skip gate check, proceed
│   ├─ advisory → Check gates, warn on failure, proceed
│   └─ strict (default) → Check gates, BLOCK on failure
│
├─ Map protocol to RCSD stage:
│   ├─ research → research stage
│   ├─ consensus → consensus stage
│   ├─ specification → specification stage
│   ├─ decomposition → decomposition stage
│   ├─ implementation/contribution → implementation stage
│   └─ release → release stage
│
├─ Check prerequisites for target stage:
│   ├─ All prior stages completed/skipped → GATE PASSES → Proceed with spawn
│   └─ Missing prerequisite stages → GATE FAILS
│
└─ On GATE FAILURE (strict mode):
    ├─ Exit code: 75 (EXIT_LIFECYCLE_GATE_FAILED)
    ├─ Error includes: missing stages, fix commands
    └─ Action: Complete prerequisite stages first
```

### Enforcement Modes

| Mode | Behavior | When to Use |
|------|----------|-------------|
| **strict** (default) | Blocks spawn if prerequisites missing | Production, regulated work |
| **advisory** | Warns but allows spawn | Rapid prototyping, debugging |
| **off** | Disables all gate checks | Legacy compatibility, emergencies |

### Setting Enforcement Mode

```bash
# Check current mode
jq '.lifecycleEnforcement.mode' .cleo/config.json

# Set to advisory (temporary)
jq '.lifecycleEnforcement.mode = "advisory"' .cleo/config.json > tmp && mv tmp .cleo/config.json

# Set back to strict
jq '.lifecycleEnforcement.mode = "strict"' .cleo/config.json > tmp && mv tmp .cleo/config.json
```

### Handling Gate Failures

When a gate fails in strict mode:

1. **Check what's missing**: Error JSON shows `missingPrerequisites`
2. **Complete prerequisites**: Spawn subagents for missing stages
3. **Record completion**: System auto-records via manifest entries
4. **Retry spawn**: Original task should now pass gate

**Example failure response:**
```json
{
  "error": {
    "code": "E_LIFECYCLE_GATE_FAILED",
    "message": "SPAWN BLOCKED: Lifecycle prerequisites not met for implementation stage",
    "context": {
      "targetStage": "implementation",
      "missingPrerequisites": "research consensus"
    }
  }
}
```

### Emergency Bypass

**Only for emergencies** - set mode to advisory or off:

```bash
# Temporary bypass for single session
export LIFECYCLE_ENFORCEMENT_MODE=off

# Or update config
jq '.lifecycleEnforcement.mode = "off"' .cleo/config.json > tmp && mv tmp .cleo/config.json
```

**Remember to restore strict mode after emergency.**

### Spawning cleo-subagent

**CRITICAL**: All spawns follow this pattern:

```bash
# 1. Detect task type and select protocol
protocol=$(skill_dispatch_by_keywords "implement auth middleware")

# 2. Prepare spawn context (resolves ALL tokens)
spawn_json=$(skill_prepare_spawn "$protocol" "T1234")

# 3. Spawn cleo-subagent with Task tool
# The spawn_json.prompt field contains the fully-resolved protocol
```

**Task Tool Invocation**:
```
Task tool parameters:
  - subagent_type: "cleo-subagent"
  - prompt: {spawn_json.prompt}  # Contains: base protocol + conditional protocol
  - task_id: "T1234"
```

## Core Workflow

### Phase 1: Discovery

```bash
cleo orchestrator start --epic T1575
cleo research pending
```

Check MANIFEST.jsonl for pending followup, review sessions and focus.

### Phase 2: Planning

```bash
cleo orchestrator analyze T1575     # Analyze dependency waves
cleo orchestrator ready --epic T1575  # Get parallel-safe tasks
```

Decompose work into subagent-sized chunks with clear completion criteria.

### Phase 3: Execution

```bash
cleo orchestrator next --epic T1575  # Get next ready task
cleo orchestrator spawn T1586        # Generate spawn prompt for cleo-subagent
```

**Spawn cleo-subagent** with protocol injection. Wait for manifest entry before proceeding.

Example spawn flow:
```bash
# Get spawn context with fully-resolved prompt
spawn_json=$(cleo orchestrator spawn T1586 --json)

# Use Task tool to spawn cleo-subagent:
#   subagent_type: "cleo-subagent"
#   prompt: $(echo "$spawn_json" | jq -r '.prompt')
```

### Phase 4: Verification

```bash
cleo orchestrator validate --subagent <research-id>
cleo orchestrator context
```

Verify all subagent outputs in manifest. Update CLEO task status.

---

## Task Operations Quick Reference

Essential CLEO commands for orchestrator coordination. For complete reference, see `~/.cleo/docs/TODO_Task_Management.md`.

### Discovery & Status

| Command | Purpose | Output |
|---------|---------|--------|
| `cleo find "query"` | Fuzzy search (minimal context) | Task IDs matching query |
| `cleo show T1234` | Full task details | Complete task metadata |
| `cleo dash --compact` | Project overview | Epic progress summary |
| `cleo analyze --parent T1575` | Dependency analysis | Wave-based task ordering |
| `cleo orchestrator ready --epic T1575` | Parallel-safe tasks | Tasks with no blocking deps |
| `cleo orchestrator next --epic T1575` | Suggest next task | Highest priority ready task |

### Task Coordination

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `cleo add "Task" --parent T1575` | Create child task | Decomposing work |
| `cleo focus set T1586` | Set active task | Before spawning subagent |
| `cleo focus show` | Check current focus | Session startup |
| `cleo complete T1586` | Mark task done | After subagent completion |
| `cleo verify T1586 --all` | Set verification gates | Quality assurance |
| `cleo deps T1586` | Check dependencies | Before spawning |

### Manifest & Research

| Command | Purpose | Context Cost |
|---------|---------|--------------|
| `cleo research list` | List research entries | Minimal (metadata only) |
| `cleo research show <id>` | Entry summary | ~500 tokens |
| `cleo research pending` | Followup items | Variable |
| `cleo research link T1586 <id>` | Link research to task | Bidirectional reference |

### Context Management

| Command | Purpose | Exit Code |
|---------|---------|-----------|
| `cleo context` | Check context usage | 0 (OK) / 50+ (warning) |
| `cleo orchestrator context` | Orchestrator-specific check | Same |

**Context Budget Rule**: Stay under 10K tokens. Use `cleo research list` over reading full files.

## Subagent Protocol Injection

**MUST** inject protocol block to EVERY spawned cleo-subagent. NO EXCEPTIONS.

### Architecture: cleo-subagent + Protocol

All spawns use a single agent type (`cleo-subagent`) with context-specific protocols:

```
Orchestrator
    │
    ├─ skill_dispatch() → selects protocol based on task
    │
    ├─ skill_prepare_spawn() → resolves ALL tokens, builds prompt
    │
    └─ Task tool (subagent_type: "cleo-subagent")
         │
         └─ cleo-subagent receives: base protocol + conditional protocol
```

### Method 1: CLI Spawn (Recommended)

```bash
# Generate fully-resolved spawn prompt
cleo orchestrator spawn T1586 --json

# Returns JSON with:
# - taskId, epicId, date
# - prompt: Base protocol + conditional protocol (tokens resolved)
# - tokenResolution.fullyResolved: true
```

### Method 2: Manual Protocol Injection

```bash
source lib/skill-dispatch.sh

# 1. Detect protocol from task
protocol=$(skill_auto_dispatch "T1586")

# 2. Get spawn context with fully-resolved prompt
spawn_context=$(skill_prepare_spawn "$protocol" "T1586")

# 3. Extract prompt for Task tool
prompt=$(echo "$spawn_context" | jq -r '.prompt')
```

### Protocol Composition

The spawn prompt combines:
1. **Base Protocol** (`agents/cleo-subagent/AGENT.md`) - Lifecycle, output format, constraints
2. **Conditional Protocol** (`protocols/*.md`) - Task-specific requirements

Example for research task:
```
## Subagent Protocol (Auto-injected)
{base protocol content with tokens resolved}

---

## Skill: research
{research protocol content with tokens resolved}
```

### Valid Return Messages

| Status | Valid Return Message |
|--------|---------------------|
| Complete | "Research complete. See MANIFEST.jsonl for summary." |
| Partial | "Research partial. See MANIFEST.jsonl for details." |
| Blocked | "Research blocked. See MANIFEST.jsonl for blocker details." |

## Common HITL Patterns

Executable workflows for typical orchestrator scenarios.

### Pattern: Starting Fresh Epic

```bash
# 1. HITL creates epic
cleo add "Implement auth system" --type epic --size large --phase core

# 2. Start orchestrator session
cleo session start --scope epic:T1575 --auto-focus

# 3. Spawn planning subagent (decomposition protocol)
cleo orchestrator spawn T1575  # Auto-detects epic → uses decomposition protocol

# 4. Wait for decomposition completion
cleo research show <research-id>

# 5. Continue with wave-0 tasks
cleo orchestrator next --epic T1575
```

### Pattern: Resuming Interrupted Work

```bash
# 1. Check state on conversation start
cleo orchestrator start --epic T1575
# Shows: session active, focus T1586, next task T1589

# 2. Check for incomplete subagent work
cleo research pending
# Shows: needs_followup: ["T1586"]

# 3. Resume focused task or spawn followup
cleo show T1586 --brief
cleo orchestrator spawn T1586  # Re-spawn if needed
```

### Pattern: Handling Manifest Followups

```bash
# 1. Query manifest for pending items
cleo research pending
# Returns: { "T1586": ["Add error handling", "Write tests"] }

# 2. Create child tasks for followups
cleo add "Add error handling to auth" --parent T1586 --depends T1586
cleo add "Write auth tests" --parent T1586 --depends T1586

# 3. Spawn for new tasks
cleo orchestrator next --epic T1575
cleo orchestrator spawn T1590
```

### Pattern: Parallel Execution

```bash
# 1. Analyze dependency waves
cleo orchestrator analyze T1575
# Shows: Wave 0: T1578, T1580, T1582 (no deps)

# 2. Verify parallel safety
cleo orchestrator ready --epic T1575
# Returns: ["T1578", "T1580", "T1582"]

# 3. Spawn multiple subagents (different sessions)
# Session A spawns T1578
# Session B spawns T1580
# Session C spawns T1582

# 4. Monitor completion via manifest
cleo research list --status complete --limit 10
```

### Pattern: Phase-Aware Orchestration

```bash
# 1. Check current phase
cleo phase show
# Returns: "core"

# 2. Get tasks in current phase
cleo orchestrator ready --epic T1575 --phase core

# 3. Spawn within phase context
cleo orchestrator spawn T1586

# 4. When phase complete, advance
cleo phases stats
cleo phase advance  # Move to testing phase
```

### Pattern: Quality Gates Workflow

```bash
# 1. Subagent completes implementation
# Returns: "Implementation complete. See MANIFEST.jsonl for summary."

# 2. Orchestrator verifies output
cleo research show <research-id>
cleo show T1586

# 3. Spawn validation subagent
cleo orchestrator spawn T1590  # Validation task

# 4. Set verification gates
cleo verify T1586 --gate testsPassed
cleo verify T1586 --gate qaPassed
cleo verify T1586 --all

# 5. Parent epic auto-completes when all children verified
```

### Pattern: Release Workflow

**Release tasks use the `release` protocol** for version management and changelog generation.

```bash
# 1. Verify all epic tasks complete
cleo list --parent T1575 --status pending  # Should be empty

# 2. Run pre-release validation
./tests/run-all-tests.sh
cleo validate

# 3. Create release (uses dev/release-version.sh)
# For patch release:
./dev/release-version.sh patch --push

# For minor release:
./dev/release-version.sh minor --push

# Preview without changes:
./dev/release-version.sh patch --dry-run
```

**Release Script Relationship**:

| Script | Purpose | Automation Level |
|--------|---------|------------------|
| `dev/bump-version.sh` | Updates VERSION + README only | Partial |
| `dev/release-version.sh` | Full release: bump + changelog + commit + tag + push | Full |
| `scripts/generate-changelog.sh` | CHANGELOG.md → Mintlify MDX | Called by release-version |

**Full RCSD-to-Release Lifecycle**:

```bash
# RCSD PIPELINE (setup phase)
cleo orchestrator spawn T100  # research protocol
cleo orchestrator spawn T101  # consensus protocol
cleo orchestrator spawn T102  # specification protocol
cleo orchestrator spawn T103  # decomposition protocol

# EXECUTION (core phase)
cleo orchestrator spawn T104  # implementation protocol
cleo orchestrator spawn T105  # implementation protocol
# ...more implementation tasks...

# CONTRIBUTION (tracked automatically)
# contribution protocol auto-triggers for shared resources

# RELEASE (polish phase)
./dev/release-version.sh minor --push
cleo session end --note "Feature X released v0.74.0"
```

---

## Autonomous Mode (AUTO-*)

**Specification**: [AUTONOMOUS-ORCHESTRATION-SPEC.md](../../docs/specs/AUTONOMOUS-ORCHESTRATION-SPEC.md)

When operating autonomously (without continuous HITL oversight), the orchestrator MUST follow these additional constraints:

### Core Autonomous Constraints

| ID | Constraint | Rationale |
|----|------------|-----------|
| AUTO-001 | Orchestrator MUST spawn ALL subagents; subagents MUST NOT spawn other subagents | Single coordination point |
| AUTO-002 | MUST read manifest `key_findings` for handoff; MUST NOT read full output files | Context preservation |
| AUTO-003 | Decomposition is separate from orchestration | Role separation |
| AUTO-004 | MUST verify manifest entry BEFORE spawning next agent | Compliance chain |
| AUTO-005 | MUST compute dependency waves; spawn in wave order | Correctness |
| AUTO-006 | MUST handle partial/blocked by creating followup tasks | Graceful degradation |
| HNDOFF-001 | MUST generate handoff at 80% context threshold | Graceful context management |
| CONT-001 | MUST read last handoff before resuming work | State recovery |

### Autonomous Workflow

```bash
# 1. Session startup
cleo session list                      # Check existing sessions
cleo session resume <id>               # OR resume existing
cleo session start --scope epic:T1575 --auto-focus  # OR start new

# 2. Wave computation
cleo orchestrator analyze T1575        # Get dependency waves

# 3. Spawn loop (for each task in wave order)
cleo orchestrator spawn T1586          # Get spawn prompt
# → Use Task tool (subagent_type: cleo-subagent)
# → Wait for return message
cleo research show <id>                # Verify manifest entry
cleo research link T1586 <id>          # Link to task

# 4. Context check (before each spawn)
cleo context                           # Check threshold

# 5. Handoff (at 80% or wave complete)
cleo session end --note "Wave 2 complete, next: T1590"
```

### Scope Boundaries

| Autonomous | Requires HITL |
|------------|---------------|
| Task execution within epic scope | Architectural decisions |
| Dependency resolution | Scope expansion |
| Manifest writing, status updates | Force/destructive operations |
| Spawning subagents in wave order | Cross-epic work |
| Creating followup tasks | Git push to main |

### Quick Reference

See @references/autonomous-operation.md for corrected injection templates and decision trees.

---

## Anti-Patterns (MUST NOT)

1. **MUST NOT** read full research files - use manifest summaries
2. **MUST NOT** spawn parallel subagents without checking dependencies
3. **MUST NOT** implement code directly - delegate to cleo-subagent
4. **MUST NOT** exceed 10K context tokens
5. **MUST NOT** skip protocol injection when spawning cleo-subagent
6. **MUST NOT** spawn tasks out of dependency order
7. **MUST NOT** spawn skill-specific agents (ct-research-agent, ct-task-executor, etc.) - use cleo-subagent with protocol injection
8. **MUST NOT** spawn cleo-subagent with unresolved tokens (check `tokenResolution.fullyResolved`)
9. **MUST NOT** write, edit, or implement code directly - all code changes are delegated to cleo-subagent

## JSDoc Provenance Requirements

All code changes MUST include provenance tags:

```javascript
/**
 * @task T1234
 * @epic T1200
 * @why Business rationale (1 sentence)
 * @what Technical summary (1 sentence)
 */
```

---

## References

For detailed workflows, load these references on demand:

| Topic | Reference |
|-------|-----------|
| Spawn workflow | @references/orchestrator-spawning.md |
| Protocol compliance | @references/orchestrator-compliance.md |
| Token injection | @references/orchestrator-tokens.md |
| Error recovery | @references/orchestrator-recovery.md |
| Autonomous mode | @references/autonomous-operation.md |

## Shared References

@skills/_shared/task-system-integration.md
@skills/_shared/subagent-protocol-base.md

---

## External Documentation

- [AUTONOMOUS-ORCHESTRATION-SPEC.md](../../docs/specs/AUTONOMOUS-ORCHESTRATION-SPEC.md) - Autonomous mode (AUTO-*, HNDOFF-*, CONT-*)
- [PROJECT-LIFECYCLE-SPEC.md](../../docs/specs/PROJECT-LIFECYCLE-SPEC.md) - Full lifecycle (RCSD → Release)
- [PROTOCOL-STACK-SPEC.md](../../docs/specs/PROTOCOL-STACK-SPEC.md) - 7 conditional protocols
- [RCSD-PIPELINE-SPEC.md](../../docs/specs/RCSD-PIPELINE-SPEC.md) - Research → Consensus → Spec → Decompose
- [ORCHESTRATOR-VISION.md](../../docs/ORCHESTRATOR-VISION.md) - Core philosophy
- [ORCHESTRATOR-PROTOCOL.md](../../docs/guides/ORCHESTRATOR-PROTOCOL.md) - Practical workflows
- [orchestrator.md](../../docs/commands/orchestrator.md) - CLI command reference
